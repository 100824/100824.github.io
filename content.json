{"meta":{"title":"丑丑与大头的博客","subtitle":"","description":"","author":100824,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有标签","date":"2020-02-19T18:48:13.000Z","updated":"2020-02-19T19:05:41.162Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-19T19:20:26.891Z","updated":"2020-02-19T19:20:26.884Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"60天重学算法05栈","slug":"04栈","date":"2020-04-17T17:30:27.000Z","updated":"2020-04-19T19:17:29.654Z","comments":true,"path":"2020/04/18/04栈/","link":"","permalink":"http://yoursite.com/2020/04/18/04%E6%A0%88/","excerpt":"","text":"什么是栈 栈是一种受限制的线性表，只允许在一段插入和删除数据 可以用链表实现，也可以用数组实现栈的应用 表达式求值 括号匹配实现浏览器的前进后退功能使用两个栈，X和Y，把首次浏览的页面一次压入栈X，当点击后退时，在依次从栈X中取出数据，并将出栈的数据一次压入栈Y。当点击前进是，依次从Y中取出数据，并一次压入X。 练手题目https://leetcode-cn.com/problems/min-stack/我的题解：https://leetcode-cn.com/problems/min-stack/solution/python-lian-biao-shi-xian-zhan-by-fu-hao-tong/","categories":[{"name":"60天重学算法","slug":"60天重学算法","permalink":"http://yoursite.com/categories/60%E5%A4%A9%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"60天重学算法04链表","slug":"03链表","date":"2020-04-16T17:30:27.000Z","updated":"2020-04-19T19:17:19.801Z","comments":true,"path":"2020/04/17/03链表/","link":"","permalink":"http://yoursite.com/2020/04/17/03%E9%93%BE%E8%A1%A8/","excerpt":"","text":"缓存淘汰策略先进先出策略 FIFO（First In，First Out）最少使用策略 LFU（Least Frequently Used）最近最少使用策略 LRU（Least Recently Used） 链表 不需要连续的空间来存储 单链表 双链表，比单链表灵活，最常用 循环链表，解决特定的问题，比如约瑟夫问题 性能对比数组 prepend 从头部插入 O(1) append 从尾部插入 O(1) lookup 查找 O(1) insert O(n) delete O(n)链表 prepend 从头部插入 O(1) append 从尾部插入 O(1) lookup 查找 O(n) insert O(1) delete O(1) 如何写链表代码 理解指针或引用的含义 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。 警惕指针丢失和内存泄漏 插入节点时需要注意操作顺序，避免节点丢失 有些语言删除节点时需要手动释放内存空间 利用哨兵简化实现难度 哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。 重点留意边界条件处理 如果链表为空时，代码是否能正常工作？ 如果链表只包含一个结点时，代码是否能正常工作？ 如果链表只包含两个结点时，代码是否能正常工作？ 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？ 举例画图，辅助思考 链表常见题型 单链表反转 链表中环的检测 两个有序的链表合并 删除链表倒数第 n 个结点 求链表的中间结点 思考题1 如何基于链表实现 LRU 缓存淘汰算法？(leetcode原题)https://leetcode-cn.com/problems/lru-cache-lcci/ （第二道）https://leetcode-cn.com/problems/lru-cache/ 我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。 现在我们来看下 m 缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。数组加字典实现LRU缓存12345678910111213141516171819202122232425262728class LRUCache: def __init__(self, capacity: int): self.cache &#x3D; capacity self.d &#x3D; &#123;&#125; self.l &#x3D; [] def get(self, key: int) -&gt; int: if key in self.l: self.l.remove(key) self.l.append(key) return self.d[key] else: return -1 def put(self, key: int, value: int) -&gt; None: if key in self.l: self.l.remove(key) self.l.append(key) self.d[key] &#x3D; value else: if len(self.l) &#x3D;&#x3D; self.cache: popkey &#x3D; self.l.pop(0) del self.d[popkey] self.l.append(key) self.d[key] &#x3D; value 单链表实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Node: def __init__(self, key, value): self.key &#x3D; key self.value &#x3D; value self.next &#x3D; Noneclass LRUCache(object): def __init__(self, capacity): &quot;&quot;&quot; :type capacity: int &quot;&quot;&quot; self.cache &#x3D; capacity self.head &#x3D; Node(-1, -1) self.tail &#x3D; Node(-1, -1) self.head.next &#x3D; self.tail self.d &#x3D; &#123;&#125; def get(self, key): &quot;&quot;&quot; :type key: int :rtype: int &quot;&quot;&quot; if key in self.d: p &#x3D; self.head while p.next.key &gt; 0 : if p.next.key &#x3D;&#x3D; key: if p.next.next.key &#x3D;&#x3D; -1: return self.d[key] tmp &#x3D; p.next p.next &#x3D; p.next.next p &#x3D; p.next tmp.next &#x3D; self.tail p.next &#x3D; tmp return self.d[key] else: return -1 def put(self, key, value): &quot;&quot;&quot; :type key: int :type value: int :rtype: None &quot;&quot;&quot; if key in self.d: self.d[key] &#x3D; value p &#x3D; self.head while p.next.key &gt; 0 : if p.next.key &#x3D;&#x3D; key: p.next.value &#x3D; value if p.next.next.key &#x3D;&#x3D; -1: return tmp &#x3D; p.next p.next &#x3D; p.next.next p &#x3D; p.next tmp.next &#x3D; self.tail p.next &#x3D; tmp else: if len(self.d) &#x3D;&#x3D; self.cache: p &#x3D; self.head a &#x3D; p.next.key p.next &#x3D; p.next.next del self.d[a] self.d[key] &#x3D; value while p.next.key &gt; 0: p &#x3D; p.next tmpnode &#x3D; Node(key, value) tmpnode.next &#x3D; p.next p.next &#x3D; tmpnode else: self.d[key] &#x3D; value p &#x3D; self.head while p.next.key &gt; 0: p &#x3D; p.next tmpnode &#x3D; Node(key, value) tmpnode.next &#x3D; p.next p.next &#x3D; tmpnode 可以使用双向链表+字典（hash）来提高效率思考题2 回文字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？ 快慢指针定位中间节点 从中间节点对后半部分逆序 前后半部分比较，判断是否为回文 后半部分逆序复原 时间复杂度On, 空间复杂度O1","categories":[{"name":"60天重学算法","slug":"60天重学算法","permalink":"http://yoursite.com/categories/60%E5%A4%A9%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"60天重学算法03数组","slug":"02数组","date":"2020-04-15T17:30:27.000Z","updated":"2020-04-19T19:08:29.532Z","comments":true,"path":"2020/04/16/02数组/","link":"","permalink":"http://yoursite.com/2020/04/16/02%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组如何实现随机访问 第一是线性表,个线性表上的数据最多只有前和后两个方向,只是简单的前后关系 第二个是连续的内存空间和相同类型的数据 正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。 为什么数组要从 0 开始编号，而不是从 1 开始呢？ 12a[k]_address &#x3D; base_address + k * type_sizea[k]_address &#x3D; base_address + (k-1)*type_size 对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。 低效的“插入”和“删除” 插入与删除的为O(n) 数组的访问越界问题 C语言中只要不是访问受限的内存，都可以自由访问，因此当数组越界时，系统不会报错，但是会访问到奇奇怪怪的数据，因为你不知道该地址存了什么数据。 python，java等语言就会做越界检查，当数组越界直接报错。 容器能否完全替代数组 对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。 课后思考 二维数组的内存寻址公式是怎样的呢？12对于m*n的数组的addr[i][j](i&lt;m, j&lt;n)address &#x3D; base_address + (i * n + j) * type_size","categories":[{"name":"60天重学算法","slug":"60天重学算法","permalink":"http://yoursite.com/categories/60%E5%A4%A9%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"60天重学算法02复杂度分析","slug":"01复杂度分析","date":"2020-04-14T17:30:27.000Z","updated":"2020-04-19T19:08:19.651Z","comments":true,"path":"2020/04/15/01复杂度分析/","link":"","permalink":"http://yoursite.com/2020/04/15/01%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"为什么需要复杂度分析 执行效率是算法一个非常重要的考量指标，是通过复杂度来衡量的。 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。 大 O 复杂度表示法 表示代码执行时间随数据规模增长的变化趋势，所以，也叫作时间复杂度。 大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。 1. 只关注循环执行次数最多的一段代码 大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。 12345678int cal(int n) &#123; int sum &#x3D; 0; int i &#x3D; 1; for (; i &lt;&#x3D; n; ++i) &#123; sum &#x3D; sum + i; &#125; return sum; &#125; 其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。这两行代码被执行了n次，所以总的时间复杂度就是O(n)。 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度 总的时间复杂度就等于量级最大的那段代码的时间复杂度。 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积常见时间复杂度 O(1) 常量级，即不会随着n的大小改变而改变只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1) O(logn)、O(nlogn)log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。所以，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn).O(nlogn)就是前一种再加上乘法法则，再嵌套一层执行n遍。 O(m+n)、O(m*n)代码的复杂度由两个数据的规模来决定 空间复杂度算法的存储空间与数据规模之间的增长关系。常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 最好、最坏时间复杂度 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。 平均情况时间复杂度 通过加权平均值等方式，得出平均时间复杂度的公式，再通过大 O 标记法，省略掉系数、低阶、常量，把公式简化之后，就得到平均时间复杂度。 均摊时间复杂度 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。 课后思考我们今天学的几个复杂度分析方法，你都掌握了吗？你可以用今天学习的知识，来分析一下下面这个add()函数的时间复杂度。 12345678910111213141516171819202122&#x2F;&#x2F; 全局变量，大小为10的数组array，长度len，下标i。int array[] &#x3D; new int[10]; int len &#x3D; 10;int i &#x3D; 0;&#x2F;&#x2F; 往数组中添加一个元素void add(int element) &#123; if (i &gt;&#x3D; len) &#123; &#x2F;&#x2F; 数组空间不够了 &#x2F;&#x2F; 重新申请一个2倍大小的数组空间 int new_array[] &#x3D; new int[len*2]; &#x2F;&#x2F; 把原来array数组中的数据依次copy到new_array for (int j &#x3D; 0; j &lt; len; ++j) &#123; new_array[j] &#x3D; array[j]; &#125; &#x2F;&#x2F; new_array复制给array，array现在大小就是2倍len了 array &#x3D; new_array; len &#x3D; 2 * len; &#125; &#x2F;&#x2F; 将element放到下标为i的位置，下标i加一 array[i] &#x3D; element; ++i;&#125; 答： 最好时间复杂度O(1),只执行了写入操作 最坏时间复杂度O(n),i&gt;=len,复制数组循环了n次 平均时间复杂度O(1)， (1+1+…+1+n)/(n+1) = 2n/(n+1)，化简后为常数级","categories":[{"name":"60天重学算法","slug":"60天重学算法","permalink":"http://yoursite.com/categories/60%E5%A4%A9%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"60天重学算法01前言","slug":"00前言","date":"2020-04-13T17:59:27.000Z","updated":"2020-04-19T19:08:10.612Z","comments":true,"path":"2020/04/14/00前言/","link":"","permalink":"http://yoursite.com/2020/04/14/00%E5%89%8D%E8%A8%80/","excerpt":"","text":"为什么要学数据结构与算法 如果在一家成熟的公司，面对的是千万级甚至是亿级的用户，开发的是TB、PB级别数据处理系统性能几乎是开发过程中时刻都要考虑的问题。一个简单的ArrayList、Linked List的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。 遇到不会的上 Google，懒了就上 GitHub 找框架。所以写了这么多年代码，一直是个菜鸟。 知识图谱需要掌握： 目标 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树； 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 每个知识点都用python实现一遍，第二遍尝试用go再实现一遍。 练习方法1. 须知 可以练习，每道题起码过五遍 练习缺项，弱项的地方 不舒服，不爽，枯燥 把它变成你的舒适区 主动型反馈，看别人的代码 看十遍也没自己实现一遍学的牢 2. 切题四件套 理解清题意 把所有可能的想法过一遍 写代码 测试用例 3.刷题方法 第一遍，五分钟思考看题，看答案，分析优劣，并记忆 第二遍，自己写，对比执行时间与 第三遍，24小时后再重复练习 第四遍，一周后，再重复练习 第五遍，面试前再刷一遍","categories":[{"name":"60天重学算法","slug":"60天重学算法","permalink":"http://yoursite.com/categories/60%E5%A4%A9%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数组与链表","slug":"数组与链表","date":"2020-03-27T17:16:06.000Z","updated":"2020-03-29T18:56:26.366Z","comments":true,"path":"2020/03/28/数组与链表/","link":"","permalink":"http://yoursite.com/2020/03/28/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/","excerpt":"","text":"时间复杂度区别数组 prepend 从头部插入 O(1) append 从尾部插入 O(1) lookup 查找 O(1) insert O(n) delete O(n)链表 prepend 从头部插入 O(1) append 从尾部插入 O(1) lookup 查找 O(n) insert O(1) delete O(1)跳表 思维：空间换时间(高级链表) 添加了索引 多级索引 两个一个索引，lookup O(logn) 维护成本高，修改需要更新索引 应用于redis中，作为有序集类型的底层数据结构之一（另一个是字典） redis为什么用跳表而不用红黑树，跳表修改后要更新的部分相对较少，锁的东西也就相对较少，红黑树有平衡的过程，牵涉到大量的节点","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"浏览器插件","slug":"浏览器插件","date":"2020-03-21T19:05:37.000Z","updated":"2020-03-21T19:51:27.266Z","comments":true,"path":"2020/03/22/浏览器插件/","link":"","permalink":"http://yoursite.com/2020/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/","excerpt":"","text":"前言之所以说是浏览器插件而不是Chrome插件是因为我本来想要使用chrome的插件功能，但是之前一直都是在用360极速浏览器，上网查了一下，突然发现原来的浏览器添加插件也是非常方便，加上自己平时习惯了用360，就直接上手360浏览器的插件，知乎简书等文章说google主要优势是快，其实我平时也没啥感觉原来的浏览器会慢。 油猴这个插件真的牛逼，用过才知道，直接在浏览器插件那里搜索tampermonkey，添加后即可使用https://greasyfork.org/zh-CN 这个地址是搜索油猴脚本的网站，免费看视频，百度云盘不限速，各种资源，浏览器快捷翻译等功能都能找到 vimium这个插件可以使你摆脱鼠标的束缚，网页上面的所有链接都可以用键盘打开，只需要按下f键，整个页面的链接就会变成字母，按下对应的字母就能跳转到相应链接（自己试试就知道了）关闭网页/恢复网页 —— x/X搜索 —— o跳转标签页-J/K","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"前端学习路线（小A）","slug":"前端学习路线（小A）","date":"2020-03-21T09:21:19.000Z","updated":"2020-03-26T18:25:45.323Z","comments":true,"path":"2020/03/21/前端学习路线（小A）/","link":"","permalink":"http://yoursite.com/2020/03/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E5%B0%8FA%EF%BC%89/","excerpt":"","text":"什么是Web前端？Web前端是互联网时代软件产品研发中不可缺少的角色。从广义上来讲，所有用户终端产品与视觉和交互有关的部分，都属于前端工程师的专业领域。 从狭义上讲，Web前端就是使用HTML、CSS、Java等专业技能和工具将产品的UI设计稿实现成网站产品，涵盖用户PC端、移动端等网页，处理视觉和交互问题。 在Web前端这个岗位兴起之前，html+css的工作是被视觉人员所承担的，而js这部分则是由后端完成的。随着智能手机和移动互联网的普及，PC端、手机端、mobile端等五花八门的应用占领着每个人的手机，随之而来各种定制化的UI风格让兼容问题变得越来越头疼。因此，有企业开始把html+css+js这部分工作独立出来，由一个新的岗位来处理，成为了一个处理视觉和交互的综合岗位，这才有了Web前端这个岗位的出现。 因此，Web前端开发行业是伴随Web兴起而细分出来的行业。实际上，Web前端是最接近产品和设计的工程师，起到衔接产品和技术的作用，它存在在互联网的每个角落，我们使用的微信里面的各种功能、小程序等都离不开web前端技术。 Web前端的前景和就业形势、薪酬如何？学习Web前端的就业面很广，选择的岗位有：前端开发工程师、资深前端开发工程师、网站重构工程师、前端架构师等等。 虽然近两年大数据、人工智能等很火，但Web前端开发依然是十分热门的，特别是随着谷歌、YouTube、FireFox等大型企业纷纷将视线转向HTML5，前端开发已经进入HTML5时代，所以，Web前端在今后十年仍有很大的发展空间。 据统计，我国HTML5前端工程师人员的缺口将达到10多万，因此，Web前端工程师是一个非常有“钱”途的职业，并且薪酬会根据技能的深入而有不同程度的增长，其中北京、上海、广州、深圳等地前端工程师的薪资待遇更是一路飙升。 就目前的广州来说，Web前端新手的月薪大概5000元左右；工作经验3年以上、有代表性作品的，月薪在一万元左右；高手级别的月薪两三万元不成问题；大师级别的会更高。 2.大量的行业内技术不精的人造成市场饱和的假象前端入门学习门槛比较低，所以很多人认为HTML、CSS、JavaScript是很简单就掌握的东西，以为在网上看点乱七八糟的教程，随便看看书，用HTML、CSS做个网页布局就可以入门了。如果真是这样，那基本每个人只要花点时间，随便学一下，就可以入行前端了，就可以称为前端开发工程师了，那还得了。 现在很多人就是这样，想着软件开发行业可以拿高薪，想快速入门做开发，这种想法其实没有错。但是只看一点点基础，随便学点东西，只会一点点皮毛就不再深入拓展，这样的技术水平，就算数量再多，市场对专业的前端开发需求依然是只增不减，不会有任何影响的。 大家可以直接去看市场数据： 那么前端开发工程师的未来路在何方？随着前端开发技术发展，移动端应用、小程序、H5游戏出现。前端开发应用场景不断拓展。走向更专业和工程化的发展。 在以后，互联网的大量工作将会需要前端开发来完成： 播放器/游戏：H5代替Flash，如Web Audio、Web Video、Canvas日常办公软件（复杂应用，并且慢慢从桌面程序演化为Web）：Office、Email、文档管理、产品设计、项目管理、代码编辑器大数据/AI配套软件（复杂应用，并且慢慢从桌面程序演化为Web）：需要大量的后台系统来做数据分析/机器学习容器/小程序：支付宝/微信/钉钉容器，各种行业功能小程序（拥有大量原生APP功能的APP成为互联网新趋势）产品信息展示类网站（炫酷应用）：各种智能设备官网、大企业官网 开发环境编译器每种方向使用的编译器都不一致，选择好的编译器就选择了好的起步，在这里推荐VS code编译器，快捷健十分广泛，打码十分方便。同时代码风格要注重，杂乱无章的代码要整理简洁、舒适 好看。 VS code的使用 代码托管每一次更改代码都可能会导致代码增删除改的错误出现，代码托管可以防止出现这种错误。在这里推荐使用git码云的代码托管。当然还可以适当了解github、SVN等托管方式（原理一致）。多人开发的话也可以使用码云。以下为廖雪峰的git教程。 git学习 小A前端学习路线首先，无论学任何一个技术，都是从零基础开始的，前端开发也是一样。做软件开发，是从事编程开发工作，必须先从语法基础开始学习，通过语法组成产品效果。 前端开发的基础语法，由HTML+CSS+JavaScript组成，这是前端开发最基本的3个语言。 HTML+CSS+JS基础 HTML+CSS HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。 JavaScript基础 理解面向对象编程、Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。 JQuery：基础使用 悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。 HTML+CSS+JS进阶 JS高级特征 正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础。 HTML5： HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储 CSS3： CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、元素进场、出场策略、炫酷CSS3网页制作。 HTTP服务和AJAX编程 AJAX上篇： Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用 AJAX下篇： JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、jQuery框架中的AjaxAPI。 学习资料推荐 W3school 菜鸟教程 《Head FirstHTML与CSS（第二版）》 《css权威指南》 《css世界》 《dom编程艺术》 《Javascript高级程序设计》 《锋利的jQuery》 《Javascript权威指南》 廖雪峰JS：https://www.liaoxuefeng.com/wiki/1022910821149312/1023020745357888 视频资料网易云课堂： web前端开发JavaScript精英课js： https://study.163.com/course/introduction.htm?courseId=1004170004&amp;_trace_c_p_k2_=94371ee5856048719b8508f46f1c9842 tips无论是学习前端还是学习其他的知识，一定要注意实践、实践、实践！知识可以先从官方文档获取，解决方法也可以上csdn、简书、博客园上搜索别人的解决的坑，但是不实践，不做项目就一定不会进步并且学习到不同的知识。 在此建议小盆友们可以写写csdn博客，总结每一个项目收获的东西知识。每一次学习的总结都会是一次豁然开朗的体会。","categories":[{"name":"综合","slug":"综合","permalink":"http://yoursite.com/categories/%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"git的使用","slug":"git的使用","date":"2020-03-21T09:17:59.000Z","updated":"2020-03-29T18:56:23.159Z","comments":true,"path":"2020/03/21/git的使用/","link":"","permalink":"http://yoursite.com/2020/03/21/git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"git：分布式版本控制系统安装： 1sudo apt-get install git 创建版本库 先创建一个文件夹 git init 初始化一个git仓库 Git add 添加文件 Git commit -m ‘说明’ 提交到仓库 Git status 检查仓库变动的状态 git diff readme.txt 检查某个文件具体修改了哪些内容 Git log 查看提交日志 Git reset –hard HEAD^ 退回上一个版本，HEAD表示当前版本，^表示上一个版本，^^表示上上个版本 跳回旧版本后想再跳回新的版本，需要在记录中找到版本的id号，Git reflog git checkout – readme.txt 把readme.txt文件在工作区的修改全部撤销,变得跟仓库的一样 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 git rm test.txt 删除文件 链接到github 先开启ssh服务，再将公钥添加到github中。 建立一个新的仓库，按照提示将本地仓库同步上去123456git remote add origin https:&#x2F;&#x2F;github.com&#x2F;100824&#x2F;git_test.gitgit push -u origin master# 以后可以用下面命令简化同步git push origin master# 从远程库克隆git clone +远程库地址（github上面有） 到这里就同步成功了 分支管理1234567891011# 创建分支git branch dev# 切换分支git checkout dev 或 git switch dev# 查看当前分支git branch# 在分支修改后记得add 与commit# 将分支合并到当前分支上（master）git merge dev# 合并后就可以删除分支了git branch -d dev 解决冲突当两个分支都有新的提交的时候，就无法使用上面的快速合并 123456789# 尝试快速合并，失败,提示必须手动解决冲突后在提交git merge newbranch# 可以使用git status查看冲突的文件# 直接打开冲突的文件，里面会有提示分支不同的信息，修改后再提交add 和commit# 查看分支的合并情况git log --graph --pretty&#x3D;oneline --abbrev-commit# 或者直接git log# 尽量不要使用fast-forward合并，使用--no-ff可以见到合并前的分支情况git merge --no-ff -m &#39;no fast-forward fixed&#39; newbranch bug分支当你在工作区的任务进行到一半，出现bug时，可以通过创建bug分支来解决bug使用stash可以将当前的工作现场隐藏起来,再创建一个bug的分支 123456789101112131415git stashgit statusgit branch debug-101git checkout debug-101# 修改提交后，再stash查看工作现场git stash list# 再用apply恢复，或者用pop恢复后同时把stash的内容删了git stash applygit stash pop# 多次stash的时候可以使用list查看，再指定要恢复的stashgit stash apply stash@&#123;0&#125;# 复制特定的提交到当前分支，不是整个分支 加的是特定的提交的编号git cherry-pick 4c8043 # 没有合并过的分支删除时需要加-Dgit branch -D &lt;name&gt; 多人协作1234567891011121314# 查看远程仓库的名称git remote# 推送分支，把该分支本地所有的提交推送到远程库,默认的名称是origingit push origin master&#x2F;newbranch# 抓取分支，clone，只能看到本地的master分支# 要在其他分支上开发需要创建远程分支到本地git checkout -b dev origin&#x2F;dev# 修改后再push上去git push origin dev# 当其他人已经向origin&#x2F;dev分支推送了他的提交，造成你的推送失败，先用git pull把新的提交从origin&#x2F;dev抓下来，在本地合并解决冲突在推送# 需要先设置本地的dev分支与origin&#x2F;dev分支的链接（提示有），再pullgit branch --set-upstream-to&#x3D;origin&#x2F;dev devgit pull# 手动解决后再commit，push 多人协作的工作模式通常是这样： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 标签管理123456789101112131415161718# 在当前的分支打标签git tag v1.0# 在历史的commit上打标签，先找到他的idgit tag v0.9 f52c633# 查看标签信息git show v0.9# 创建带有说明的标签，用-a指定标签名，-m指定说明文字git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb# 标签的修改# 删除git tag -d v1.0# 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。# 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;git push origin v1.0# 一次性推送全部尚未推送的标签git push origin --tags# 远程删除标签，需要特定格式git push origin :refs&#x2F;tags&#x2F;v0.9","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"VScode上手教程","slug":"VScode上手教程","date":"2020-03-13T17:31:08.000Z","updated":"2020-03-21T19:20:22.502Z","comments":true,"path":"2020/03/14/VScode上手教程/","link":"","permalink":"http://yoursite.com/2020/03/14/VScode%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B/","excerpt":"","text":"vscode上手教程由于电脑太多个软件，pycharm，goland，sublime，还有对markdowm的支持不是很友好，所以决定上手传说中强大的vscode 下载直接从官网下载即可https://code.visualstudio.com 汉化为了方便熟悉软件，先使用了汉化版，直接在插件搜索chinese，点击install之后重启，就OK了 接入linux子系统打开后提示我可以安装一个插件，用于直接打开及编辑linux子系统的文件（非常方便），于是就按着提示下载了（remote-WLS）。试了一下，的确非常方便，可以直接打开linux的整个工作目录，而且也能直接运行命令行的命令。 搭建运行环境万能语言运行环境 （Code Runner），安装这个插件，然后打开某个.py文件，ctrl+shift+N即可运行，非常方便 搭建python环境第一次打开.py文件会提示你安装python的插件，按提示安装后就可以调试代码了（前提是电脑已经安装了python） 远程开发工具插件Remote Development，通过SSH(Secure Shell)的方式连接到远程服务器，开发很方便，先记着，以后会用到。 markdowm插件Markdown Preview Enhanced，预览的界面得到优化Markdown PDF 可以直接导出pdf leetcode插件直接搜索leetcode插件安装，可能需要另外安装node.js，然后输入登录的账号密码就可以在vscode上刷leetcode 快捷操作 F5 开启调试 ctrl+shift+ ` 打开终端 ctrl+shift+F 打开搜索 ctrl + delete 删除右边 home 跳到行头 end 跳到行尾 ctrl 单词切分 Ctrl + ← 删除整个单词 shift 加方向键 选取 ctrl+shift+ N 打开新的窗口 ctrl+shift+ W 关闭当前窗口 ctrl+ P 快速打开 ctrl+shift+ P 显示命令面板 ctrl+shift+ \\ 跳转到匹配括号 ALT+ ↑ ↓ 当前行上移下移 ctrl + C 复制行 ctrl + X 剪切行 ctrl + shift ↑ ↓ 向上向下复制当前行 ctrl + shift + K 删除行 ctrl + home 跳到文章开头 ctrl + end 跳到文章末 ctrl + G 跳转到。。行 ctrl + H 替换 ctrl + D 跳到下一个查找匹配 F12 跳转到定义 shift + F12 显示引用 ctrl + K 再加F12 将定义打开到侧边 ctrl + F4 关闭当前标签页 ctrl + - = 放大，缩小 ctrl + B 打开关闭侧边栏 F5 调试 继续F5 下一个断点 F11 下一步 shift + F5 停止调试","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"数据结构与算法02","slug":"数据结构与算法02","date":"2020-03-12T20:10:20.000Z","updated":"2020-03-12T20:10:20.203Z","comments":true,"path":"2020/03/13/数据结构与算法02/","link":"","permalink":"http://yoursite.com/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9502/","excerpt":"","text":"七天算法训练营(题集)七天七道leetcode的题 day 1《remove-duplicates-from-sorted-array》 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 题目：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 解题思路：由于是有序数组，所以直接遍历一遍，比较相邻的数，如果相同就把后一个pop掉 12345678910111213class Solution(object): def removeDuplicates(self, nums): listlen &#x3D; len(nums) if listlen &#x3D;&#x3D; 0 or listlen &#x3D;&#x3D; 1: return listlen i &#x3D; 1 while i &lt; listlen: if nums[i] !&#x3D; nums[i-1]: i +&#x3D; 1 else: nums.pop(i) listlen -&#x3D; 1 return i day 2《rotate-array》 https://leetcode-cn.com/problems/rotate-array/ 题目：给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 解题思路：1.循环k次，每一次pop掉最后一个数，并insert到最前2.用切片方法，对数字拼接，同理第一种3.用旋转次数对数组长度取余，得到实际旋转的次数，再用切片方法一次完成旋转 12345class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: for i in range(k): tmp &#x3D; nums.pop(-1) nums.insert(0,tmp) 123456class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: for i in range(k): tmp &#x3D; [1] tmp[0] &#x3D; nums.pop(-1) nums[:] &#x3D; tmp + nums 12345class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: k &#x3D; k % len(nums) tmp &#x3D; nums[-k:] nums[:] &#x3D; tmp + nums[:-k] day 3《merge-sorted-array》 https://leetcode-cn.com/problems/merge-sorted-array/ 题目：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。 思路：循环m+n次，在将两个数组从头开始对比，若nums1大于nums2，nums1的下标后移一位，如果nums1小于或等于nums2，则将nums1的最后一位pop掉，再将nums2插入，同时下标后移一位 123456789101112131415161718192021222324class Solution(object): def merge(self, nums1, m, nums2, n): if len(nums2) &#x3D;&#x3D; 0: return nums1 tmp1 &#x3D; 0 tmp2 &#x3D; 0 for i in range(m+n): if m &#x3D;&#x3D; 0: while tmp2 &lt; n: nums1.pop() nums1.insert(i,nums2[tmp2]) tmp2 +&#x3D; 1 i +&#x3D; 1 return nums1 if nums1[tmp1] &lt;&#x3D; nums2[tmp2]: m -&#x3D; 1 else: nums1.pop() nums1.insert(i,nums2[tmp2]) tmp2 +&#x3D; 1 if tmp2 &#x3D;&#x3D; n: break tmp1 +&#x3D; 1 return nums1 day 4《merge-two-sorted-lists》 https://leetcode-cn.com/problems/merge-two-sorted-lists/ 题目：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 思路：两个链表从头比较，小的插入新的链表，同时下标后移，当其中一个链表遍历完时，再将另一个链表剩下的部分插入到新的链表后面，空间复杂度略有不足，可以直接创建一个链表头，然后将两个链表的节点一个一个接上。 12345678910111213141516171819202122232425262728class Solution(object): def mergeTwoLists(self, l1, l2): if l1 &#x3D;&#x3D; None: return l2 if l2 &#x3D;&#x3D; None: return l1 tmp1 &#x3D; l1 tmp2 &#x3D; l2 newhead &#x3D; ListNode(None) newhead.next &#x3D; None newlist &#x3D; newhead while tmp1 and tmp2: cur &#x3D; newlist if tmp1.val &lt;&#x3D; tmp2.val : newlist.val &#x3D; tmp1.val tmp1 &#x3D; tmp1.next else: newlist.val &#x3D; tmp2.val tmp2 &#x3D; tmp2.next tmp &#x3D; ListNode(None) tmp.next &#x3D; None newlist.next &#x3D; tmp newlist &#x3D; newlist.next if tmp1 &#x3D;&#x3D; None: cur.next &#x3D; tmp2 else: cur.next &#x3D; tmp1 return newhead 改进方法： 12345678910111213141516171819class Solution(object): def mergeTwoLists(self, l1, l2): prehead &#x3D; ListNode(-1) prev &#x3D; prehead while l1 and l2: if l1.val &lt;&#x3D; l2.val: prev.next &#x3D; l1 l1 &#x3D; l1.next else: prev.next &#x3D; l2 l2 &#x3D; l2.next prev &#x3D; prev.next # exactly one of l1 and l2 can be non-null at this point, so connect # the non-null list to the end of the merged list. prev.next &#x3D; l1 if l1 is not None else l2 return prehead.next day 5《two-sum》 https://leetcode-cn.com/problems/two-sum 题目：给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 思路：1.暴力法，直接两次for循环遍历，找出相符条件的数。2.哈希，参考其他大神的方法，能显著提高时间复杂度。 暴力法： 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: lenth &#x3D; len(nums) for i in range(lenth): for j in range(i+1,lenth): if nums[i] &#x3D;&#x3D; target - nums[j]: return [i,j] return None 哈希： 123456789def twoSum(nums, target): hashmap&#x3D;&#123;&#125; for i,num in enumerate(nums): if hashmap.get(target - num) is not None: return [i,hashmap.get(target - num)] hashmap[num] &#x3D; i #这句不能放在if语句之前，解决list中有重复值或target-num&#x3D;num的情况作者：lao-la-rou-yue-jiao-yue-xiang链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;two-sum&#x2F;solution&#x2F;xiao-bai-pythonji-chong-jie-fa-by-lao-la-rou-yue-j&#x2F; 后面两道暂时不会，日后再补齐 day 6《design-circular-deque》 https://leetcode.com/problems/design-circular-deque 题目： 思路： 12 day 7《trapping-rain-water》 https://leetcode.com/problems/trapping-rain-water/ 题目： 思路：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"python处理excel文件","slug":"python处理excel文件","date":"2020-03-03T17:25:16.000Z","updated":"2020-03-03T18:03:29.150Z","comments":true,"path":"2020/03/04/python处理excel文件/","link":"","permalink":"http://yoursite.com/2020/03/04/python%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/","excerpt":"","text":"python处理excel文件起因：女朋友在手动处理excel文件，说她处理得好烦。我就看了一下需求，。发现可以用python来处理。需求：一个excel表格，只有一列的内容，每隔五行为一道选择题，需要把每道题都拎出来成为独立一行。放入到一个新的表格中。格式：输入表 A1 A2 A3 A4 A5 B1 B2 B3 B4 B5 输出表 A1 A2 A3 A4 A5 B1 B2 B3 B4 B5 代码： 12345678910111213141516171819202122#!coding:utf8import xlrd #读取模块import openpyxl #写入模块# 设置好输入和输出文件f1 &#x3D; xlrd.open_workbook(r&#39;C:\\Users\\53517\\Desktop\\人工智能导论题库 (100题).xlsx&#39;)sheet1 &#x3D; f1.sheet_by_index(1) #读取excel表格中的第一个表格num &#x3D; sheet1.col_values(1) #第一个表格中的第一列workbook &#x3D; openpyxl.Workbook() #临时存储对象sheet &#x3D; workbook.activesheet.title &#x3D; &#39;test&#39; #新生成表的名字long &#x3D; len(num) #总行数print(long)k &#x3D; 0for i in range(0, long&#x2F;5): for j in range(0, 5): sheet.cell(row&#x3D;i + 1, column&#x3D;j + 1, value&#x3D;str(num[k])) k +&#x3D; 1workbook.save(r&#39;C:\\Users\\53517\\Desktop\\output1.xlsx&#39;)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"数据结构与算法01","slug":"数据结构与算法01","date":"2020-02-28T17:59:27.000Z","updated":"2020-02-28T18:36:26.147Z","comments":true,"path":"2020/02/29/数据结构与算法01/","link":"","permalink":"http://yoursite.com/2020/02/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9501/","excerpt":"","text":"数据结构与算法训练营1. 前言 可以练习，每道题起码过五遍 练习缺项，弱项的地方 不舒服，不爽，枯燥 把它变成你的舒适区 主动型反馈，看别人的代码 2. 切题四件套 理解清题意 把所有可能的想法过一遍 写代码 测试用例 3.刷题方法 第一遍，五分钟思考看题，看答案，分析优劣，并记忆 第二遍，自己写，对比执行时间与 第三遍，24小时后再重复练习 第四遍，一周后，再重复练习 第五遍，面试前再刷一遍 操作小技巧 fn + delete 删除右边 home 跳到行头 end 跳到行尾 ctrl 单词切分 Ctrl + delete 删除整个单词 shift 加方向键 选取 IDE的使用top tips 工欲善其事,必先利其器 刻意化练习","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-02-19T19:10:52.709Z","updated":"2020-02-19T19:10:52.703Z","comments":true,"path":"2020/02/20/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hi","slug":"hi","permalink":"http://yoursite.com/categories/hi/"}],"tags":[]},{"title":"肺炎疫情数据抓取","slug":"肺炎疫情数据抓取","date":"2020-02-19T18:12:48.000Z","updated":"2020-02-28T18:37:06.332Z","comments":true,"path":"2020/02/20/肺炎疫情数据抓取/","link":"","permalink":"http://yoursite.com/2020/02/20/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]}]}